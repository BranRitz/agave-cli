#!/bin/bash
#
# jobs-batch-submit
#
# author: dooley@tacc.utexas.edu
#
# This script is part of the Agave API command line interface (CLI).
# It submits a job for execution by the API.
#

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

source "$DIR/common.sh"

# Script logic -- TOUCH THIS {{{

# A list of all variables to prompt in interactive mode. These variables HAVE
# to be named exactly as the longname option definition in usage().
interactive_opts=(apisecret apikey filetoupload)

# Print usage
usage() {
  echo -n "$(basename $0) [OPTION]...

Batch create and submit jobs based using a job request template and a parameter
file. Unlike standard loop-based parameter sweeps, this command allows you to
iterate over parameters as well as input files (both local and remote) to
create the individual jobs comprising your sweep.

The format of the parameter file is flexible, allowing you to specify your jobs
in the following ways:

  * Value list: one value per line. Each line represents a job.
  * Attribute;Value list: semi-colon delimited tuple representing the attribute
    to which the value will be assigned. Each line represents a job.
  * Job;Attribute;Value tuples: semi-colon delimited tuple representing a unique
    job name, the attribute to be assigned, and the value to assign. Each line
    represents a single variable replacement. Multiple replacements are grouped
    by the job name and will all be applied within a single job.

The format of the batch job template is identical to a normal job request. You
may replace actual input or parameter values with the name of the parameter
surrounded by %. For example, if your app had an input named dataset, you could
denote this as the variable to parameterize by setting the value in the template
to %dataset%.

ex. To run a parameter sweep over the head-5.97 app, the following is the job
request produced from running `jobs-template head-5.97`
{
  \"name\": \"\",
  \"appId\": \"head-demo-5.97\",
  \"archive\": true,
  \"inputs\": {
    \"inputFile\": [
      \"dooley/inputs/fasta/example.fa\"
    ]
  },
  \"parameter\": {
    \"numberOfBytes\": 0,
    \"numberOfLines\": 10
  }
}

Run this app over a directory of files, you would replace the default inputFile
value with %inputFile% to produce the following:

{
  \"name\": \"\",
  \"appId\": \"head-demo-5.97\",
  \"archive\": true,
  \"inputs\": {
    \"inputFile\": [
      \"%inputFile%\"
    ]
  },
  \"parameter\": {
    \"numberOfBytes\": 0,
    \"numberOfLines\": 10
  }
}

The parameter file to create this batch job would look something like:

agave://data.iplantcollaborative.org/dooley/jobs/1.txt
agave://data.iplantcollaborative.org/dooley/jobs/2.txt
agave://data.iplantcollaborative.org/dooley/jobs/3.txt
agave://data.iplantcollaborative.org/dooley/jobs/4.txt
agave://data.iplantcollaborative.org/dooley/jobs/5.txt

This will result in 5 jobs being submitted. 

OLDIFS=$IFS
IFS=";"
while read jobid attribute value
 do


 done < $1
 IFS=$OLDIFS

 Options:
  -z, --access_token  Access token
  -T, --template      The job request template file used to create the actual
                      job requests by substituting parameter values from the
                      config file.
  -F, --parameters    The parameter file containing the values over which to
                      iterate and create jobs. Use - if piping in the value or
                      reading from stdin.
  -W, --watch         Watch the job history after it has been submitted, updating
                      every few seconds until the job reaches a terminal state.
  -H, --hosturl       URL of the service
  -d, --development   Run in dev mode using default dev server
  -f, --force         Skip all user interaction
  -i, --interactive   Prompt for values
  -q, --quiet         Quiet (no output)
  -v, --verbose       Verbose output
  -V, --veryverbose   Very verbose output
  -h, --help          Display this help and exit
      --version       Output version information and exit
"
}

##################################################################
##################################################################
#						Begin Script Logic						 #
##################################################################
##################################################################

source "$DIR/jobs-common.sh"

main() {
	#echo -n
	#set -x

  if [[ -z "$filetoupload" ]]; then

    response="Please provide a valid job request with the -F option."
    err "$response"

  elif [[ -d "$filetoupload" ]]; then

    response="Directory input is not supported"
    err "$response"

  elif [[ ! -e "$filetoupload" ]] && [[ "$filetoupload" != "-" ]]; then

    response="No job request found at $filetoupload"
    err "$response"

  else

    # reading from stdin
    if [[ "$filetoupload" == "-"  ]]; then

      cmd="curl -sk -H \"${authheader}\" -H \"Content-Type: application/json\" -X POST --data-binary @- $hosturl?pretty=true"

      if ((veryverbose)); then
        [ "$piped" -eq 0 ] && log "Calling $cmd"
      fi

      # make sure we specify content type as application/json
      response=`curl -sk -H "${authheader}" -H "Content-Type: application/json" -X POST --data-binary @- "$hosturl?pretty=true"`

    # standard file upload
    else

      cmd="curl -sk -H \"${authheader}\" -X POST -d \"fileToUpload=@$filetoupload\" $hosturl?pretty=true"

      if ((veryverbose)); then
        [ "$piped" -eq 0 ] && log "Calling $cmd"
      fi

      response=`curl -sk -H "${authheader}" -X POST -F "fileToUpload=@$filetoupload" "$hosturl?pretty=true"`

    fi

  	if [[ $(jsonquery "$response" "status") = 'success' ]]; then

      if ((watch)); then

        jobwatchid=$(jsonquery "$response" "result.id")

        result=$(format_api_json "$response")
        success "$result"

        if ((development)); then
          jhparams=" -d "
        fi

        if ((veryverbose)); then

          jhparams="$jhparams -V "

        elif ((verbos)); then

          jhparams="$jhparams -v "
        fi

        jobs-history $jhparams -W $jobwatchid

      else

        result=$(format_api_json "$response")
  		  success "$result"

      fi

    else

      errorresponse=$(jsonquery "$response" "message")
  		err "$errorresponse"

  	fi

  fi
}

format_api_json() {

	if ((veryverbose)); then
		echo "$1"
	elif [[ $verbose -eq 1 ]]; then
		result=$(jsonquery "$1" "result" 1)
		echo "${result}" | python -mjson.tool
	else
		jobid=$(jsonquery "$1" "result.id")
		echo "Successfully submitted job $jobid"
	fi
}

##################################################################
##################################################################
#						End Script Logic						 #
##################################################################
##################################################################

# }}}

# Parse command line options
source "$DIR/options.sh"


# Main loop {{{

# Print help if no arguments were passed.
[[ $# -eq 0 ]] && set -- "-i"

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; safe_exit ;;
    --version) version; copyright; disclaimer; safe_exit ;;
    -z|--access_token) shift; access_token=$1 ;;
    -F|--filetoupload) shift; filetoupload=$1 ;;
    -W| --watch) watch=1;;
    -H|--hosturl) shift; hosturl=$1;;
  	-d|--development) development=1 ;;
    -v|--verbose) verbose=1 ;;
    -V|--veryverbose) veryverbose=1; verbose=1 ;;
    -q|--quiet) quiet=1 ;;
    -i|--interactive) interactive=1 ;;
    -f|--force) force=1 ;;
    --endopts) shift; break ;;
    *) die "invalid option: $1" ;;
  esac
  shift
done

# Store the remaining part as arguments.
args+=("$@")

# }}}

# Run the script logic
source "$DIR/runner.sh"
