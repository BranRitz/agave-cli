#!/bin/bash
# 
# auth-token-get.sh
# 
# author: dooley@tacc.utexas.edu
#
# This script is part of the Agave API command line interface (CLI).
# It retrieves an authentication token from the auth service that
# can be used to authenticate to the rest of the api. A valid API 
# secret and key must be used to obtain a token.
#

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

source "$DIR/common.sh"

# set to 1 to prevent using cache. token creation requires a valid key
disable_cache=1
storetoken=0

# Script logic -- TOUCH THIS {{{

# A list of all variables to prompt in interactive mode. These variables HAVE
# to be named exactly as the longname option definition in usage().
interactive_opts=(apisecret apikey)

# Print usage
usage() {
  echo -n "$(basename $0) [OPTION]...

Create a new auth token. Tokens can be restricted to a specific number
of uses and/or timeframe during which they are valid. Tokens can also 
have an internal user attached to them. When interacting with systems, 
the authentication credentials of the internal user, if available, will
be used instead of those of the API user.

For ease of use, the -S option can be specified to store the new 
credential for reuse in subsequent calls to the API.

 Options:
  -s, --apisecret   API secret for authenticating
  -k, --apikey      API key for authenticating, its recommended to insert
                    this through the interactive option
  -l, --lifetime    Lifetime of the returned token in seconds
  -m, --maxUses     Maximum number of times the returned token can be used
  -u, --internalUsername  Internal user to attach to this token
  -x, --apiusername API username for whom the returned token should apply, 
                    requires admin permissions
  -S, --storetoken  Store the token for later use. This prevents you from 
                    reauthenticating with every command.
  -H, --hosturl     URL of the service
  -d, --development Run in dev mode using default dev server
  -f, --force       Skip all user interaction
  -i, --interactive Prompt for values
  -q, --quiet       Quiet (no output)
  -v, --verbose     Verbose output
  -V, --veryverbose Very verbose output
  -h, --help        Display this help and exit
      --version     Output version information and exit
"
}

##################################################################
##################################################################
#						Begin Script Logic						 #
##################################################################
##################################################################

source "$DIR/auth-common.sh"

main() {
	#echo -n
	#set -x
	
	local post_options='';
	
	if [ -n "$internalUsername" ]; then
		post_options="internalUsername=${internalUsername}"
	fi
	
	if [ -n "$apiusername" ]; then
		post_options="username=${apiusername}&${post_options}"
	fi
	
	if [ -n "$maxUses" ]; then
		post_options="maxUses=${maxUses}&${post_options}"
	fi
	
	if [ -n "$lifetime" ]; then
		post_options="lifetime=${lifetime}&${post_options}"
	fi
	
	post_options=${post_options%&}
	
	cmd="curl -sku \"$apisecret:XXXXXX\" -X POST -d \"$post_options\" $hosturl?pretty=true"

	if ((veryverbose)); then
		log "Calling $cmd"
	fi
		
	response=`curl -sku "$apisecret:$apikey" -X POST -d "$post_options" "$hosturl?pretty=true"`
	
	if [[ $(jsonquery "$response" "status") = 'success' ]]; then
		result=$(format_api_json "$response")
		success "$result"
	else
		err $(jsonquery "$response" "message")
	fi
	
	
}

format_api_json() {
	
	if ((storetoken)); then
		if [ -n "$apiusername" ]; then
			apisecret=$apiusername;
		fi
		jsonval response_token "$1" "token" 
		echo "{\"apisecret\":\"$apisecret\",\"apikey\":\"$response_token\"}" > ~/.agave
		echo "Token successfully stored";
	fi	
		
	if ((veryverbose)); then
		echo "$1"
	elif [[ $verbose -eq 1 ]]; then
		result=$(jsonquery "$1" "result" 1)
		echo "${result}" | python -mjson.tool
	else
		result=$(jsonquery "$1" "result.token")
		echo "${result}"
	fi
}

##################################################################
##################################################################
#						End Script Logic						 #
##################################################################
##################################################################

# }}}

# Parse command line options
source "$DIR/options.sh"


# Main loop {{{

# Print help if no arguments were passed.
[[ $# -eq 0 ]] && set -- "-i"

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; safe_exit ;;
    --version) out "$(basename $0) $version"; safe_exit ;;
    -s|--apisecret) shift; apisecret=$1 ;;
    -k|--apikey) shift; apikey=$1 ;;
    -l|--lifetime) shift; lifetime=$1 ;;
  	-m|--maxUses) shift; maxuses=$1 ;;
  	-u|--internalUsername) shift; internalUsername=$1 ;;
	-x|--apiusername) shift; apiusername=$1;;
	-S|--storetoken) storetoken=1 ;;
	-H|--hosturl) shift; hosturl=$1;;
  	-d|--development) development=1 ;;
    -v|--verbose) verbose=1 ;;
    -V|--veryverbose) veryverbose=1; verbose=1 ;;
    -q|--quiet) quiet=1 ;;
    -i|--interactive) interactive=1 ;;
    -f|--force) force=1 ;;
    --endopts) shift; break ;;
    *) die "invalid option: $1" ;;
  esac
  shift
done

# Store the remaining part as arguments.
args+=("$@")

# }}}

# Run the script logic
source "$DIR/runner.sh"

